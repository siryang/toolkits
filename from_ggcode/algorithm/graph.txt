V: 定点集合
E: 边的集合
G: 图

有向图:	G = (V, E)
转置:	G = (V, E)的转置是Gt = (V, Et), Et = {(v, u) ∈ V × V: (u, v) ∈ E}

图的表示:  邻接表、邻接矩阵
	邻接表适合稀疏图。
	邻接矩阵适合稠密图、需要尽快判断给定两个顶点是否存在连接边
	
强连通图:
	图中的每一对节点 (v, u)都存在u → v和v ← u
	
强连通分支：
	将G=(V, E)中的节点分为多个G1=(V1, E1) G2=(V2, E2)...使每个子图都是强连通图

深度优先搜索，DSF:
	深度优先搜索能遍历一个图，将其分为几个有连通性的森林。
	时间戳: 深度优先搜索每个节点有两个时间戳，d(do第一次检测到)和f(finish结束检查)
	任选一个节点，开始深度遍历此节点能到达的节点，直到遇到此节点的所有出边能到达的节点都d过, 则记录f
	
	性质1.括号定理
		[d(u), f(u)] 与 [d(v), f(v)]的关系有三种，完全不想交、包含、包含于代表u是v互不为后裔、祖先、后裔三种关系
	性质2.后裔区间的嵌套
		v是u的后裔 <====> d(u) < d(v) < f(v) < f(u)
	性质3.白色路径定理
		v是u的后裔 <====> 当d(u)时发现u后，可以从u出发经过一条白色定点组成的路径到达v
	
强连通分支:
	http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591370.html
	Kosaraju算法: 利用了原图G和转置图Gt
		1.利用深度优先搜索将原图加工成森林
		2.对Gt进行深度优先搜索，本次按照1中f从大到小遍历。2加工出来的森林就是一个个强连通分支。
		
		复杂度Θ(V+E)
		需要转置图
	
	Tarjan算法:单次深度优先搜索，但需要在搜索时回溯
		1.进行DSF搜索，当节点无更深节点可以递归时回溯，对每个回溯到的节点，找栈中到其能到达的次序最小的节点(这步又是对每个节点递归，如果节点很多，有点麻烦，不过应该可以优化...)。
		2.如果节点无法递归，且其能达到的次序最小的节点也是自身，则栈上将此节点前面的元素中能到达次序最小为此节点的元素一起组成一个硬连通分支
		
		用递归来做好
		复杂度Θ(V+E)，与Kosaraju相比，优点是不用逆图，更简洁，运行效率高30%左右
		
	
最小生成树	
	Kruskal: 
		发音: 克鲁斯卡尔
	Prim:
		发音: 普利姆
	
最短路径
	Dijkstra
	SPFA
	Bellman-Ford
	Folyd-Warshall
	A*
	Johnson



