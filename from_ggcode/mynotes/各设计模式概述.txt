久闻《设计模式》之大名，深知做为一名自认为未来会很牛B的程序员如今不懂《设计模式》是一件可耻的事情，却一直没有开始去学。

一日，在火车上无事可做，便拿起《C++设计模式》读了起来，忽然发现很多东西和我已经做过的有想通之处，甚至比我曾写过的代码更深入，于是，思考之前的某些代码可以套用哪些设计模式，便一发不可收拾。



针对对象的创建
首先是工厂模式。

了解的模式
1.创建型
	Factory
	Abstract Factory
	Singleton
	Builder
	Prototype
	
2.结构型
	Adapter
	


Bridge模式，将抽象定义和具体实现分开，当定义的同一个接口有多种不同实现的情况出现时使用。
			Interface    =  sort()
			achieve  	 =  1.insert_sort ; 2.quick_sort ....
		疑问：Bridge和Policy的不同。

Decorator 模式，增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。
		当需要为一个对象增加行为，如果使用继承的话，会出现很多子类，所以不想修改/继承原有的类。
	
		疑问？
			可是这个模式，为什么不用单纯的组合。
			据我理解，后期类的扩充需要增加许多属性，而我们如果为每种组合都创建一个类，代码会很乱。
			于是，将这个过程交给了调用者。
			由调用者来组合。就像我们提供了0-9，调用者便可以组合出任意阿拉伯数字。
	
			可以说，和我们常用的组合比起来，一个是静态增加行为，一个是动态增加行为。
	
	
Composite 模式，



